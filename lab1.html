<!DOCTYPE html>

<!--
THEME MODIFIED FROM THEMEFISHER HTML TEMPLATE
 // WEBSITE: https://themefisher.com
-->

<html lang="zxx">

	<head>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1, shrink-to-fit=no"
		/>
		<meta name="author" content="Spike" />
		<!-- <link rel="icon" href="icon.gif" type="image/gif" /> -->
		<link rel="icon" href="img/me_circle.png" />
		<title>Fast Robots Lab 1</title>
		<meta name="keywords" content="lab1, fastRobots, arduino, artemis nano," />

  <!-- ** Plugins Needed for the Project ** -->
  <!-- Bootstrap -->
  <link rel="stylesheet" href="css/bootstrap.min.css">
  <!-- Main Stylesheet -->
   <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css"> -->
	<link rel="stylesheet" href="css/atelier-seaside-light.css">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
	<script>hljs.highlightAll();</script>
  <link href="css/style.css" rel="stylesheet">
  <link href="css/page.css" rel="stylesheet">

</head>

<body>
  
<!-- Header Start --> 
<nav class="navbar navbar-expand-lg sticky-top navbar-dark bg-dark tab-navigation" style="z-index: 1020">
    <div class="container-xxl">
<ul class="nav nav-tabs w-100" style="border-bottom: none">
    <li class="nav-item flex-fill text-center">
        <a href="index.html" class="nav-link tab-link">Home</a>
    </li>

    <li class="nav-item flex-fill text-center mx-1">
        <a href="#" class="nav-link tab-link active">Fast Robots</a>
    </li>
    
    <li class="nav-item flex-fill text-center">
        <a href="lab1.html" class="nav-link tab-link active" style="border-bottom: 2px solid #47daff; font-size: 0.9em;">Lab 1</a>
    </li>
    <li class="nav-item flex-fill text-center">
        <a href="lab2.html" class="nav-link tab-link" style="font-size: 0.9em;">Lab 2</a>
    </li>
    <li class="nav-item flex-fill text-center">
        <a href="lab3.html" class="nav-link tab-link" style="font-size: 0.9em;">Lab 3</a>
    </li>
</ul>
    </div>
</nav>



<!-- Header Close --> 

<!-- Hero Section -->
<section class="section pt-5 pb-0">
  <div class="container">
    <div class="row">
      <div class="col-lg-4">
        <div class="mb-4">
		  <h2 class="mb-5">Fast Robots: Lab 1</h2>
		  <img src="img/lab1/lab1Box.gif" alt="Fast Robots Lab 1" style="width: 100%; height: auto; display: block; border-radius: 8px; margin-bottom: 20px;">
          <p><span class="text-color-hover-light">Arduino IDE</span> • <span class="text-color-hover-light">Bluetooth</span> • <span class="text-color-hover-light">Jupyter Notebooks</span></p> 
		</div>
	</div>
      <div class="col-lg-8">
        <div class="mb-4">
          <h3 class="text-color mb-4">Introduction to Using Artemis Nano</h3>
          <p class="lead">This lab is to serve as an introduction to using the Arduino IDE and Jupyter notebooks 
			to communicate with the Artemis Nano microcontroller. We look at a few peripherals and communicate 
			with the board via bluetooth and serial communication.</p>
          <!-- <p class="mt-3">The purpose of Lab 1 is to setup and become familiar with the Arduino IDE and 
			the Artemis board. This lab involves programming your board, using the board 
			LED, reading/writing serial messages over USB, and using the onboard temperature sensor and Pulse 
			Density Microphone.</p> -->
        </div>
      </div>
    </div>
  </div>
</section>

<!-- Hero Video -->
<!-- <section class="section pt-0 pb-5">
	<div class="container">
		<div class="row">
			<div class="col-12">
				<video controls autoplay muted loop style="width: 100%; height: auto; display: block; border-radius: 8px;" poster="images/portfolio/HRC/hrc2_cover_wide.png">
					<source src="images/portfolio/HRC/HRC_Codesign.mp4" type="video/mp4">
					<img src="images/portfolio/HRC/hrc2_cover_wide.png" alt="Human-Robot Co-design" style="width: 100%; height: auto; display: block; border-radius: 8px;">
				</video>
			</div>
		</div>
	</div>
</section> -->

<!-- prelab -->
<section class="section pt-5 pb-1 bg-secondary">
  <div class="container">
    <div class="row mb-5">
      <div class="col-lg-8 offset-lg-2">
        <h4 class="text-color-hover-light mb-2">Plugging it in</h4>
        <h2 class="mb-4">Hooking Up The Board</h2>
        <p>Before we begin, we must have a method to interact with the board.
			To do this, we use the Arduino IDE, and add the Sparkfun Appollo3 board support package via this 
			<a href="https://raw.githubusercontent.com/sparkfun/Arduino_Apollo3/main/package_sparkfun_apollo3_index.json">link</a>.
			After installing the board support package, we can select the Sparkfun Artemis Nano as our target board, plug in the board,
			and upload code to it.
		</p>
      </div>
    </div>
  </div>
</section>

<section class="section pt-4 pb-1">
  <div class="container">
    <div class="row mb-5">
      <div class="col-lg-8 offset-lg-2">
        <h4 class="text-color-hover-light mb-2">Simplest Example</h4>
        <h2 class="mb-4">Blinking the Board LED</h2>
			<p>
				Running the built-in Arduino example "Blink" causes the board's LED to blink.
			</p>
			<section class="section pt-0 pb-1">
				<div class="container">
					<div class="row">
						<div class="col-12">
							<video controls style="width: 100%; height: auto; display: block; border-radius: 8px;" poster="img/lab1/blinkCover.png" preload="none">
								<source src="img/lab1/blink.MOV" type="video/mp4">
								<img src="img/lab1/blinkCover.png" style="width: 100%; height: auto; display: block; border-radius: 8px;">
							</video>
						</div>
					</div>
				</div>
			</section>
		</div>
    </div>
  </div>
</section>

<section class="section pt-4 pb-1 bg-secondary">
  <div class="container">
    <div class="row mb-5">
      <div class="col-lg-8 offset-lg-2">
        <h4 class="text-color-hover-light mb-2">Reading Values</h4>
        <h2 class="mb-4">Serial Communication</h2>
			<p>
				Running the built-in Apollo3 example "Serial" allows us to read and write serial values from the board.
				For this example, it counts up and then echos what we send to it. The baudrate is set to 115200.
			</p>
			<section class="section pt-0 pb-1">
				<div class="container">
					<div class="row">
						<div class="col-12">
							<img src="img/lab1/serialOutput.jpg" alt="Fast Robots Lab 1 Serial Capture" style="width: 100%; height: auto; display: block; border-radius: 8px;">
						</div>
					</div>
				</div>
			</section>
		</div>
    </div>
  </div>
</section>

<section class="section pt-4 pb-1">
  <div class="container">
    <div class="row mb-5">
      <div class="col-lg-8 offset-lg-2">
        <h4 class="text-color-hover-light mb-2">Analog Read</h4>
        <h2 class="mb-4">Temperature Sensor</h2>
			<p>
				Running the built-in Apollo3 example "Analog Read" allows us to read from the onboard temperature sensor.
				For this example, as I put my finger on the board, the temperature reading increases from ~13000 to ~65000.
			</p>
			<section class="section pt-0 pb-1">
				<div class="container">
					<div class="row">
						<div class="col-12">
							<video controls class="video-portrait" poster="img/lab1/tempCover.png" preload="none">
								<source src="img/lab1/temp.mov" type="video/mp4">
								<img src="img/lab1/tempCover.png" style="width: 100%; height: auto; display: block; border-radius: 8px;">
							</video>
						</div>
					</div>
				</div>
			</section>
		</div>
    </div>
  </div>
</section>

<section class="section pt-4 pb-1 bg-secondary">
  <div class="container">
    <div class="row mb-5">
      <div class="col-lg-8 offset-lg-2">
        <h4 class="text-color-hover-light mb-2">Talking into the mic</h4>
        <h2 class="mb-4">Microphone Sensor</h2>
			<p>
				Running the built-in PDM example "Microphone Output" allows us to read from the onboard Pulse Density Microphone.
				For this example, as I make a light noise into the microphone, the pitch reading increases from ~750 to ~9000.
			</p>
			<section class="section pt-0 pb-1">
				<div class="container">
					<div class="row">
						<div class="col-12">
							<video controls class="video-portrait" poster="img/lab1/micCover.png" preload="none">								<source src="img/lab1/mic.mov" type="video/mp4">
								<img src="img/lab1/micCover.png" style="width: 100%; height: auto; display: block; border-radius: 8px;">
							</video>
						</div>
					</div>
				</div>
			</section>
		</div>
    </div>
  </div>
</section>

<section class="section pt-4 pb-1">
  <div class="container">
    <div class="row mb-5">
      <div class="col-lg-8 offset-lg-2">
        <h4 class="text-color-hover-light mb-2">5000-Level Task</h4>
        <h2 class="mb-4">Note Detector</h2>
			<p>
				For the final task, I created a simple note detector that prints the note 
				that is detected by the microphone by monitoring the pitch from the microphone.
				The note ranges are as follows:

				<br>
				C5 (523Hz): 525-527Hz<br>
				B4 (494Hz): 491-494Hz<br>
				D5 (587Hz): 582-584Hz<br>
			</p>

			<pre data-lang="Arduino"><code>ui32LoudestFrequency = (sampleFreq * ui32MaxIndex) / pdmDataBufferSize;

if (ui32LoudestFrequency <= 527 && ui32LoudestFrequency >= 525)
{
	Serial.printf("Detecting an C5 (523Hz)\n");
}
if (ui32LoudestFrequency <= 494 && ui32LoudestFrequency >= 491)
{
	Serial.printf("Detecting an B4 (494Hz)\n");
}
if (ui32LoudestFrequency <= 584 && ui32LoudestFrequency >= 582)
{
	Serial.printf("Detecting an D5 (587Hz)\n");
}</code></pre>
			<section class="section pt-0 pb-1">
				<div class="container">
					<div class="row">
						<div class="col-12">
							<video controls poster="img/lab1/noteCover.png" preload="none">								
								<source src="img/lab1/note.mov" type="video/mp4">
								<img src="img/lab1/noteCover.png" style="width: 100%; height: auto; display: block; border-radius: 8px;">
							</video>
						</div>
					</div>
				</div>
			</section>
		</div>
    </div>
  </div>
</section>

<section class="section pt-4 pb-1 bg-secondary">
  <div class="container">
    <div class="row mb-5">
      <div class="col-lg-8 offset-lg-2">
        <h4 class="text-color-hover-light mb-2">Start of Lab1B</h4>
        <h2 class="mb-4">Lab Setup</h2>
			<p>
				For the start of Lab1B, we set up the bluetooth module to communicate with the Artemis Nano.
				We use the ArduinoBLE library to advertise the board as a bluetooth device, and create a custom service
				and characteristic to send and receive data. We can then connect to the board via bluetooth from a Jupyter notebook
				using the Bleak library.
			</p>
			<p>
				To setup the Python module, we setup a virtual environment and install the Bleak, asyncio, jupyterlab, 
				and other dependencies libraries via pip using the commands below:
			</p>
			<pre data-lang="bash"><code>python3 -m venv FastRobots_ble
.\FastRobots_ble\Scripts\activate
pip install numpy pyyaml colorama nest_asyncio bleak jupyterlab</code></pre>

			<p>
				We were given a sample Jupyter notebook and arduino sketch to connect to the board via bluetooth and send/receive messages 
				(downloadable <a href="https://fastrobotscornell.github.io/FastRobots-2026/labs/ble_robot_1.4.zip">here</a>).
				However, to connect to the board, we must first find the MAC address of the board by running the "ble_arduino.ino"
				which prints the MAC address to the serial monitor as shown below. We can then input this MAC address into the 
				connections.yaml file which is used by our Python script to connect.
			</p>
			<img src="img/lab1/macAddress.png" alt="Fast Robots Lab 1 Serial Capture" style="width: 100%; height: auto; display: block; border-radius: 8px; margin-bottom: 20px;">

			<p>
				We also need to generate a UUID for our custom bluetooth service and characteristic. This can be done by importing the UUID module
				in Python and generating a random UUID using the command below: 
			</p>
			<pre data-lang="python"><code>import uuid
print(uuid.uuid4())</code></pre>
			<p>
				After generating the UUIDs, we can input them into both the Arduino sketch and the connections.yaml file. Which allows us to connect
				to the board via bluetooth and send/receive messages. The codebase for both the Arduino sketch and Jupyter notebook already contains 
				helper functions to make sending and receiving messages easier. Such as "send_command" and "recieve_string/float/int" in the Python notebook
				which lets us send commands, which are then processed by ble_arduino.ino, and read the data from the board.
			</p>
		</div>
    </div>
  </div>
</section>

<section class="section pt-4 pb-1">
  <div class="container">
    <div class="row mb-5">
      <div class="col-lg-8 offset-lg-2">
        <h4 class="text-color-hover-light mb-2">Echo Echo Echo Echo....</h4>
        <h2 class="mb-4">First Command</h2>
			<p>
				We edited the provided Arduino sketch to add a new command "Echo" which echos back any string sent to it.
				In this case we tak on "Robot says -> " before the echoed string to differentiate it from other messages.
			</p>

			<pre data-lang="Arduino"><code>case ECHO:

char char_arr[MAX_MSG_SIZE];

// Extract the next value from the command string as a character array
success = robot_cmd.get_next_value(char_arr);
if (!success)
	return;

tx_estring_value.clear();
tx_estring_value.append("Robot Says -> ");
tx_estring_value.append(char_arr);
tx_characteristic_string.writeValue(tx_estring_value.c_str());

Serial.print("Sent back: ");
Serial.println(tx_estring_value.c_str());

break;</code></pre>

		<img src="img/lab1/echoCommand.png" alt="Fast Robots Lab 1 Serial Capture" style="width: 100%; height: auto; display: block; border-radius: 8px; margin-bottom: 20px;"/>
		<img src="img/lab1/echoCommandPython.png" alt="Fast Robots Lab 1 Jupyter Capture" style="width: 100%; height: auto; display: block; border-radius: 8px; margin-bottom: 20px;"/>
		
	</div>
    </div>
  </div>
</section>

<section class="section pt-4 pb-1 bg-secondary">
  <div class="container">
    <div class="row mb-5">
      <div class="col-lg-8 offset-lg-2">
        <h4 class="text-color-hover-light mb-2">Float Float Float</h4>
        <h2 class="mb-4">Send Three Floats</h2>
			<p>
				We added another command which takes three floats and prints them
				back to the serial monitor. This command extracts three float values from the command string with the "|"
				acting as a delimiter between values.
			</p>

			<pre data-lang="Arduino"><code>case SEND_THREE_FLOATS:
float float_a, float_b, float_c;

// Extract the next value from the command string as an integer
success = robot_cmd.get_next_value(float_a);
if (!success)
	return;

// Extract the next value from the command string as an integer
success = robot_cmd.get_next_value(float_b);
if (!success)
	return;

// Extract the next value from the command string as an integer
success = robot_cmd.get_next_value(float_c);
if (!success)
	return;

Serial.print("Three floats: ");
Serial.print(float_a);
Serial.print(", ");
Serial.print(float_b);
Serial.print(", ");
Serial.println(float_c);

break;</code></pre>

		<img src="img/lab1/sendThreeFloats.png" alt="Fast Robots Lab 1 Serial Capture" style="width: 100%; height: auto; display: block; border-radius: 8px; margin-bottom: 20px;"/>
		<img src="img/lab1/sendThreeFloatsPython.png" alt="Fast Robots Lab 1 Jupyter Capture" style="width: 100%; height: auto; display: block; border-radius: 8px; margin-bottom: 20px;"/>
		
	</div>
    </div>
  </div>
</section>

<section class="section pt-4 pb-1">
  <div class="container">
    <div class="row mb-5">
      <div class="col-lg-8 offset-lg-2">
        <h4 class="text-color-hover-light mb-2">What Time Is It?</h4>
        <h2 class="mb-4">Get Time Millis</h2>
			<p>
				We added another command which outputs the current time in milliseconds since the board started.
				The command takes an argument of 0,1,2 which corresponds to sending out one value, appending
				values to an array, or also monnitoring the temperature. The second and third options are used in later tasks below.
			</p>

			<pre data-lang="Arduino"><code>case GET_TIME_MILLIS:
{
// list or no list
// If send_bool == 0 dont append to array, if send_bool == 1 append to array and dont send
int send_bool;
robot_cmd.get_next_value(send_bool);
if (!success)
{
	return;
}
			
// No Character sent - send back current time
int timeSinceStart = millis();
if (send_bool == 0)
{
	tx_estring_value.clear();
	tx_estring_value.append("T:");
	tx_estring_value.append(timeSinceStart);
	tx_characteristic_string.writeValue(tx_estring_value.c_str());

	return;
}</code></pre>

		<img src="img/lab1/getTimeMillisCommand.png" alt="Fast Robots Lab 1 Serial Capture" style="width: 100%; height: auto; display: block; border-radius: 8px; margin-bottom: 20px;"/>
		
	</div>
    </div>
  </div>
</section>

<section class="section pt-4 pb-1 bg-secondary">
  <div class="container">
    <div class="row mb-5">
      <div class="col-lg-8 offset-lg-2">
        <h4 class="text-color-hover-light mb-2">Got It</h4>
        <h2 class="mb-4">Notification Handler</h2>
			<p>
				To immediately process the data when it is received from the board, we set up a notification handler which parses
				the time string and prints just the millisecond time to the console as soon as it is received.
			</p>

			<pre data-lang="Python"><code>def notification_handler(characteristic, data):
    # need to decode raw data byte array
    decoded = ble.bytearray_to_string(data[2:])
    print(decoded)
ble.start_notify(ble.uuid['RX_STRING'], notification_handler)</code></pre>

		<img src="img/lab1/notificationHandler.png" alt="Fast Robots Lab 1 Serial Capture" style="width: 100%; height: auto; display: block; border-radius: 8px; margin-bottom: 20px;"/>
		
	</div>
    </div>
  </div>
</section>

<section class="section pt-4 pb-1">
  <div class="container">
    <div class="row mb-5">
      <div class="col-lg-8 offset-lg-2">
        <h4 class="text-color-hover-light mb-2">Got It Got It Got It....</h4>
        <h2 class="mb-4">Notification Handler Loop</h2>
			<p>
				To see how fast we can get the time values, we set up a loop to continuously send the get time command.
			</p>

			<pre data-lang="Python"><code>for i in range(15):
    ble.send_command(CMD.GET_TIME_MILLIS, "0")</code></pre>

		<img src="img/lab1/notification handler loop.png" alt="Fast Robots Lab 1 Serial Capture" style="width: 10%; height: auto; display: block; border-radius: 8px; margin: 0 auto;"/>
		
		<p>
			As seen above, we are able to get time values at around 180 ms intervals. Since we are sending an integer, this is about 4 Bytes of data, but the Arduino also sends "T:" before the integer.
			This means we are sending about 6 Bytes of data every 180 ms, which is about 33.33 Bytes per second.
		</p>
	</div>
    </div>
  </div>
</section>

<section class="section pt-4 pb-1">
  <div class="container">
    <div class="row mb-5">
      <div class="col-lg-8 offset-lg-2">
        <h4 class="text-color-hover-light mb-2">Faster Got It....</h4>
        <h2 class="mb-4">Batch Sending</h2>
			<p>
				To send values faster, we can use the array sending option of the get time command to send multiple values at once.
				We send the get time command with the argument of 1 to append values to an array on the Arduino side, and then use a new 
				command "SEND_TIME_DATA" to send the entire array at once.
			</p>

			<pre data-lang="Arduino"><code>if (send_bool == 1)
{
	while (timeStampArrayIndex < MAX_CAPACITY) {
		timeSinceStart = millis();
		timeStampArray[timeStampArrayIndex] = timeSinceStart;
		timeStampArrayIndex++;
	}
}</code></pre>

<pre data-lang="Arduino"><code>case SEND_TIME_DATA:
{
	int i = 0;
	for (i=0; i < timeStampArrayIndex; i++) {
		tx_estring_value.clear();
		tx_estring_value.append("T:");
		tx_estring_value.append(timeStampArray[i]);
		tx_characteristic_string.writeValue(tx_estring_value.c_str());
	}

	// reset time array
	memset(timeStampArray, 0, sizeof(timeStampArray));
	timeStampArrayIndex = 0;
	
	break;
}</code></pre>

		<img src="img/lab1/allAtOnce.png" alt="Fast Robots Lab 1 Serial Capture" style="width: 100%; height: auto; display: block; border-radius: 8px; margin: 0 auto;"/>
		
		<p>
			In the Python code above, we run our commands, and print out the time reading from the beginning and end of the batch 
			(starts at index 15 because I ran the previous loop test first). Our MAX_CAPACITY is set to 1000. We can see that we are able to get
			1000 time readings in about 21 milliseconds, giving 6000B/21ms = ~285 kilobytes per second. This is a significant improvement over the previous method of sending one value at a time.
		</p>
	</div>
    </div>
  </div>
</section>

<section class="section pt-4 pb-1">
  <div class="container">
    <div class="row mb-5">
      <div class="col-lg-8 offset-lg-2">
        <h4 class="text-color-hover-light mb-2">Temperature and Time</h4>
        <h2 class="mb-4">Get Temp Readings</h2>
			<p>
				We then implement a feature to monitor the temperature while getting time readings.
				We use the array sending option of the get time command to send values rapidly in the form
				"T:[InsertTime]D:[InsertTemp]" where T is the time in milliseconds and D is the temperature reading in fahrenheit.
				To command the board to start appending values to the array, we send the get time command with the argument of 2.
				To send the entire array at once, we create a new command "GET_TEMP_READINGS".
			</p>

			<pre data-lang="Arduino"><code>if (send_bool == 2)
	{
	float temp_f;
	while (timeStampArrayIndex < MAX_CAPACITY) {
		timeSinceStart = millis();
		temp_f = getTempDegF();
		timeStampArray[timeStampArrayIndex] = timeSinceStart;
		tempReadingArray[timeStampArrayIndex] = temp_f;
		timeStampArrayIndex++;
	}
	}</code></pre>

<pre data-lang="Arduino"><code>case GET_TEMP_READINGS:
{
	int i = 0;
	for (i=0; i < timeStampArrayIndex; i++) {
		tx_estring_value.clear();
		tx_estring_value.append("T:");
		tx_estring_value.append(timeStampArray[i]);
		tx_estring_value.append("D:");
		tx_estring_value.append(tempReadingArray[i]);
		tx_characteristic_string.writeValue(tx_estring_value.c_str());
	}

	// reset time array
	memset(timeStampArray, 0, sizeof(timeStampArray));
	timeStampArrayIndex = 0;

	// reset temp array
	memset(tempReadingArray, 0, sizeof(tempReadingArray));
	tempReadingArrayIndex = 0;
	
	break;
}</code></pre>

<p>Since we change the format of the recieved data on the Python side, we need to update the notification handler accordingly.</p>

<pre data-lang="Python"><code>timeStampArray = []
tempArray = []
def notification_handler(characteristic, data):
    # need to decode raw data byte array
    decoded = ble.bytearray_to_string(data)
    # in form: decoded = 'T:123D:456' (time, degree)
    decoded = decoded.split(':')
    timeStr = decoded[1][:-1]
    degStr = decoded[2]
    # print(decoded)
    tempArray.append(degStr)
    timeStampArray.append(timeStr)
ble.start_notify(ble.uuid['RX_STRING'], notification_handler)

ble.send_command(CMD.GET_TIME_MILLIS, "2")
ble.send_command(CMD.GET_TEMP_READINGS, "")

for t, d in zip(timeStampArray[:1000:100], tempArray[:1000:100]):
    print(f'Time is: {t}, Current Temp (F) is: {d}')</code></pre>

		<img src="img/lab1/TempAndTimeOutput.png" alt="Fast Robots Lab 1 Serial Capture" style="width: 100%; height: auto; display: block; border-radius: 8px; margin: 0 auto;"/>

	</div>
    </div>
  </div>
</section>

<section class="section pt-4 pb-1 bg-secondary">
  <div class="container">
    <div class="row mb-5">
      <div class="col-lg-8 offset-lg-2">
        <h4 class="text-color-hover-light mb-2">Comparisons</h4>
        <h2 class="mb-4">Data Rate Transfer Speeds</h2>
        <p>
			The advantages and disadvantages of each method are summarized below:

			<br><br>
			<strong>Single Value Transfer:</strong><br>
			• Simple to implement and understand.<br>
			• Lower data transfer rates due to overhead of individual transmissions since Python has to send 
			a command, then the board has to process that command and send the data back before new data can be received.
			This means that we are heavily bottlenecked by communication latency over Bluetooth.<br>
			• Suitable for applications where data is needed without high precision or in small amounts, or when needed immediately.<br>
			• Had a data transfer rate of ~33.33 Bytes/second in our implementation.<br>
			<br>

			<strong>Batch Value Transfer:</strong><br>
			• More complex to implement due to the need for buffering and managing larger data sets.<br>
			• We have to store the entire batch of data in memory on the microcontroller before sending, which could be a limitation for very large data sets.<br>
			• Significantly higher data transfer rates as multiple values are sent in a single transmission, reducing overhead,
			since only two commands need to be sent back and forth to save and then transfer all the data.<br>
			• Ideal for applications requiring highly precise data acquisition or large data sets.<br>
			• Had a data transfer rate of ~285K Bytes/second in our implementation.<br>
			<br>

			If we use the second method of batch value transfer, we can achieve much higher data transfer rates.
			In the case of sending time and temperature readings, we have 12 Bytes of data being sent per reading (T:xxxxD:xxx).
			Since the Artemis board has 384kB of RAM, we can store a maximum of about 32,000 readings in memory at once
			(384,000B / 12B per reading = 32,000 readings). This means that we can send a batch of 32,000 readings in one go
			without running out of memory.
		</p>
      </div>
    </div>
  </div>
</section>

<section class="section pt-4 pb-1">
  <div class="container">
    <div class="row mb-5">
      <div class="col-lg-8 offset-lg-2">
        <h4 class="text-color-hover-light mb-2">5000-Level Task</h4>
        <h2 class="mb-4">Data Rate Versus Message Size</h2>
			
		<p>
			To test how message size affects data transfer rate, I sent 100 messages of varying sizes from 1 Byte to 147 Bytes. The maximum size we can send is 147 Bytes
			since the maximum string size we can send over is 150 Bytes, and we have to reserve 3 Bytes for overhead. The command used to send the messages is "TIMED_ECHO" which echos back
			the sent string without any additional text. The time taken between sending and recieving the message is recorded to calculate the data transfer rate via a notification handler.
			For each message size from 1 to 147 Bytes, I sent 100 messages and recorded the response times.
			The results and code snippets are shown in the plot below.
		</p>

		<pre data-lang="Arduino"><code>case TIMED_ECHO:
{
	// Echo's back to the python notebook without printing'
	char char_arr[MAX_MSG_SIZE];

	// Extract the next value from the command string as a character array
	success = robot_cmd.get_next_value(char_arr);
	if (!success)
		return;

	tx_estring_value.clear();
	tx_estring_value.append(char_arr);
	tx_characteristic_string.writeValue(tx_estring_value.c_str());

	break;
}</code></pre>

<pre data-lang="Python"><code>respTimes = []
sentTime = 0
mesgCount = 0
def notification_handler(characteristic, data):
    global responseInFlight, mesgCount
    mesgCount += 1
    respTimes.append(time.time() - sentTime)
ble.start_notify(ble.uuid['RX_STRING'], notification_handler)

respMap = {}
for i in range(1, 148):
    testStr = 'a'*i
    respTimes = []
    mesgCount = 0
    # send 100 messages
    numMsg = 100
    for j in range(numMsg):
        responseInFlight = True
        sentTime = time.time()
        ble.send_command(CMD.TIMED_ECHO, testStr)
        
    ble.sleep(0.1) # give the controller time to process incoming messages
    
    respMap[i] = np.array(respTimes)</code></pre>

		<img src="img/lab1/roundTripTimeVsSize.png" alt="Fast Robots Lab 1 Data Rate vs Message Size" style="width: 100%; height: auto; display: block; border-radius: 8px; margin: 0 auto;"/>
		<img src="img/lab1/dataRateVsSize.png" alt="Fast Robots Lab 1 Average Response Time vs Message Size" style="width: 100%; height: auto; display: block; border-radius: 8px; margin: 0 auto;"/>

		<p>
			The plot on the left shows the round trip time distributions for different message sizes, while the plot on the right shows the average response time and data rate (Bytes/second) versus message size with bars for standard deviation.
		</p>
		<p>
			From these plots we can see that as the message size increases, the average response time also increases linearly, albeit slightly. This is expected as larger messages take longer to transmit over Bluetooth.
			However, the increase in response time is relatively small compared to the increase in message size. As a result, the data rate (Bytes/second) also increases with message size.
			For example, the data rate for 5 byte messages is 82.79 Bytes/second, while for 147 byte messages it is 1,820.11 Bytes/second.
			The variability in response times also increases with message size, likely due to the increased likelihood of interference and retransmissions for larger packets. 
			Smaller messages seem to introduce a large amount of overhead since it has to send a packet over bluetooth for each message, leading to lower data rates.
			Overall, these results suggest that for applications requiring high data throughput, it is more efficient to send larger messages rather than many small messages since each large message has the same overhead but sends more real data.
		</p>
	</div>
    </div>
  </div>
</section>

<section class="section pt-4 pb-1">
  <div class="container">
    <div class="row mb-5">
      <div class="col-lg-8 offset-lg-2">
        <h4 class="text-color-hover-light mb-2">5000-Level Task Part 2</h4>
        <h2 class="mb-4">Reliability Test</h2>
			
		<p>
			By modifying the GET_TIME_MILLIS command to send 1000 time readings in a loop without waiting for any commands from Python,
			we can test the reliability of the data transfer by checking how many messages are lost during transmission.
			In this case, we send 1000 time readings as fast as possible and record how many readings are received on the Python side.
			The code snippet for sending the readings is shown below.
		</p>

		<pre data-lang="Arduino"><code>if (send_bool == 0)
{
	int timeSinceStart = millis();
	int i = 0;
	for (i=0; i < 1000; i++)
	{
	timeSinceStart = millis();
	tx_estring_value.clear();
	tx_estring_value.append("T:");
	tx_estring_value.append(timeSinceStart);
	tx_characteristic_string.writeValue(tx_estring_value.c_str());
	}

	return;
}</code></pre>

<p>
	On the python side we used the notification handler from the part above to record how many readings were received.
	After running the test multiple times, we found that we were able to receive all 1000 readings consistently without any loss.
	This indicates that the data transfer is reliable for this use case even when sending a large number of messages in quick succession. However, it did take some time for all of the messages to come through.
</p>
	</div>
    </div>
  </div>
</section>


<section class="section pt-4 pb-1">
  <div class="container">
    <div class="row mb-5">
      <div class="col-lg-8 offset-lg-2">
        <h4 class="text-color-hover-light mb-2">Finishing Up</h4>
        <h2 class="mb-4">Discussion</h2>
<p>
	This lab provided valuable hands-on experience with Bluetooth communication between a microcontroller and a host computer which will be useful for future robotics projects where we won't have direct wired connections.
	It also showed different methods of data transfer and their trade-offs in terms of speed and reliability.
	Implementing both single value and batch value transfer methods highlighted the importance of choosing the right approach based on application requirements.
</p>
	</div>
    </div>
  </div>
</section>

<section class="section pt-4 pb-1">
  <div class="container">
    <div class="row mb-5">
      <div class="col-lg-8 offset-lg-2">
        <!-- <h4 class="text-color-hover-light mb-2">Giving Credit</h4> -->
        <!-- <h2 class="mb-4">Citations</h2> -->

        <div class="mt-5 p-4" style="border-left: 4px solid #47ffc5; background: #f7f7f7;">
          <p class="mb-0" style="font-style: italic;">ChatGPT was used to help format parts of this website and report as well as debug some issues with the reliability test code.
			<a href="https://aidan-mcnay.github.io/fast-robots-docs/lab1/" target="_blank">Aiden McNay's website</a> was used as a reference for the data rate vs message size task and graphs.
			I also worked closely with Ananya Jajodia and Shao Stassen for this lab.
		  </p>
        </div>
	</div>
    </div>
  </div>
</section>




<!-- Footer start -->
<section class="footer">
	<div class="container">
		<div class="row ">
			<div class="col-lg-6">
				<p class="mb-0">Copyrights © 2019. Designed & Developed by <a href="themefisher.com">Themefisher</a></p>
			</div>
			<div class="col-lg-6">
				<div class="widget footer-widget text-lg-right mt-5 mt-lg-0">
					<ul class="list-inline mb-0">
						<li class="list-inline-item"><a href="https://github.com/heisen-kong" target="_blank"><i class="ti-github mr-3"></i></a></li>
						<li class="list-inline-item"><a href="https://www.linkedin.com/in/heisen-kong/" target="_blank"><i class="ti-linkedin mr-3"></i></a></li>
						<li class="list-inline-item"><a href="https://www.instagram.com/heisens.creations/" target="_blank"><i class="ti-instagram mr-3"></i></a></li>
					</ul>
				</div>
			</div>
		</div>
	</div>
</section>
<!-- Footer End -->

<!-- jQuery -->
<script src="plugins/jQuery/jquery.min.js"></script>
<!-- Bootstrap JS -->
<script src="plugins/js/bootstrap.min.js"></script>
<script src="plugins/aos/aos.js"></script>
<script src="plugins/owl-carousel/owl.carousel.min.js"></script>
<script src="plugins/shuffle/shuffle.min.js"></script>
<script src="plugins/magnific-popup/jquery.magnific-popup.min.js"></script>
<script src="plugins/animated-text/animated-text.js"></script>
<script src="plugins/counto/apear.js"></script>
<script src="plugins/counto/counTo.js"></script>

 <!-- Google Map -->
<script src="plugins/google-map/map.js"></script>
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAkeLMlsiwzp6b3Gnaxd86lvakimwGA6UA&callback=initMap"></script> 
<!-- Main Script -->
<script src="js/script.js"></script>

</html>